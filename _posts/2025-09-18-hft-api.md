---
layout: post
title: 'High-Frequency Trading API: When the Speed of Light is a Bug'
date: 2025-09-18
category: QA
slug: hft-api
gpgkey: EBE8 BD81 6838 1BAF
tags:
- quality-assurance
---

## Table of Contents

- [Table of Contents](#table-of-contents)
- [Introduction](#introduction)
- [TL;DR](#tldr)
- [The Microsecond Mindset](#the-microsecond-mindset)
- [Kernel Bypass and FPGA](#kernel-bypass-and-fpga)
- [Code Snippet: Measuring Latency Distribution](#code-snippet-measuring-latency-distribution)
- [Summary](#summary)
- [Key Takeaways](#key-takeaways)
- [Next Steps](#next-steps)

## Introduction

In typical Web APIs, "Fast" is 50ms. In High-Frequency Trading (HFT), 50ms is not slow; it is bankruptcy.

We operate in **Microseconds** (Âµs) and **Nanoseconds** (ns). The speed of light is a bug. (Light travels 30cm in 1ns.
That is one foot. Every foot of cable costs money.)

**QA Challenge**: You cannot use `Date.now()`. It is too slow. You cannot use `console.log`. It blocks the thread. You
need hardware timestamps and a severe caffeine addiction.

## TL;DR

- **Garbage Collection is death**: In Java/Go, a GC pause destroys latency. QA must verify "Zero-Allocation" code paths.
- **Jitter matters more than average**: Average latency is irrelevant. The 99.99th percentile (p9999) is everything. If
  1 in 10,000 trades is slow, you lose.
- **Fairness is legally mandated**: The exchange must process orders in exact arrival sequence (FIFO). If you process my
  competitor first, I sue you.

## The Microsecond Mindset

You cannot use HTTP. You cannot use JSON. You use **UDP Multicast** and binary protocols (FIX / SBE / Ouch).

QA tools like Postman are useless here. They are toys. You need **pcap** (Packet Capture) and **Wireshark**. Your test
runner must be on the same switch as the System Under Test (SUT). If you are testing over Wi-Fi, leave the building.

## Kernel Bypass and FPGA

The Linux Kernel is too slow. It performs context switches. We do not like those.

HFT apps use **DPDK** (Data Plane Development Kit) or **Solarflare OpenOnload** to bypass the OS and talk directly to
the NIC (Network Card).

**QA Strategy**: Verify that the CPU core pinning is correct. If the test runner thread context switches to handle a
mouse movement, your measurement is invalid. Isolate the cores. Treat them like precious snowflakes.

## Code Snippet: Measuring Latency Distribution

Standard tools are not precise enough. We use high-resolution timers (`process.hrtime.bigint` in Node, though in real
HFT you would use C++ `rdtsc`).

```javascript
/*
  latency-histogram.js
*/

// Using HDR Histogram for high-dynamic-range latency tracking
// npm install hdr-histogram-js
// Because 'average' lies.
const hdr = require('hdr-histogram-js');

const histogram = hdr.build({
    bitBucketSize: 32,
    highestTrackableValue: 1000 * 1000 * 1000, // 1 second in ns
    numberOfSignificantValueDigits: 5
});

function benchmarkOrderEntry() {
    const iterations = 100000;
    
    for (let i = 0; i < iterations; i++) {
        const start = process.hrtime.bigint();
        
        // Simulate "Send Order" (Mock function)
        // In reality, this writes to a ring buffer in shared memory
        sendOrderToExchange();
        
        const end = process.hrtime.bigint();
        const latency = Number(end - start); // Nanoseconds
        
        histogram.recordValue(latency);
    }
}

function sendOrderToExchange() {
    // Busy wait simulation (Fast operation)
    // We don't sleep. Sleeping yields the CPU. We spin.
    let x = 0;
    while(x < 100) x++; 
}

console.log('Running Micro-Benchmark...');
benchmarkOrderEntry();

console.log('\n--- Latency Report (ns) ---');
console.log(`Mean:    ${histogram.getMean()}`);
console.log(`p50:     ${histogram.getValueAtPercentile(50)}`);
console.log(`p99:     ${histogram.getValueAtPercentile(99)}`);
console.log(`p99.99:  ${histogram.getValueAtPercentile(99.99)}`); // The "Tail Event" that gets you fired.
console.log(`Max:     ${histogram.maxValue}`);
```

## Summary

HFT QA is closer to physics than software engineering. You are fighting the hardware. If a cable is loose, your test
fails. If the room is too hot, the crystal oscillator drifts, and your test fails (Clock Skew).

It is fun, in a masochistic sort of way. If you enjoy pain and precision, you will love it.

## Key Takeaways

- **Deterministic replay is essential**: You must be able to replay a day's worth of market data (billions of messages)
  exactly as it happened to reproduce a bug.
- **Lock-free or go home**: Verify your code uses no Mutexes or Semaphores on the hot path. Locks are slow.
- **Clock sync requires precision**: Use PTP (Precision Time Protocol), not NTP. NTP is too jittery for our purposes.

## Next Steps

- **Tool**: **Wireshark** with the FIX protocol dissector. Learn to read binary.
- **Learn**: Understand **Ring Buffers** (Disruptor pattern). Queues are too slow.
- **Hardware**: Get a server with **Solarflare** NICs for your test lab. Tell your boss it is cheaper than a lawsuit.
