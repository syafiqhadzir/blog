---
layout: post
title: 'The 12-Factor App: Testing Cloud-Native Apps'
date: 2023-08-24
category: QA
slug: 12-factor-app
gpgkey: EBE8 BD81 6838 1BAF
tags:
- quality-assurance
---

## Table of Contents

- [Table of Contents](#table-of-contents)
- [Introduction](#introduction)
- [TL;DR](#tldr)
- [Factor III: Config](#factor-iii-config)
- [Factor X: Dev/Prod Parity](#factor-x-devprod-parity)
- [Code Snippet: Config Validation](#code-snippet-config-validation)
- [Summary](#summary)
- [Key Takeaways](#key-takeaways)
- [Next Steps](#next-steps)

## Introduction

Heroku's **12-Factor App** manifesto changed everything. It took us from "copy-pasting ZIP files to FTP servers" to "git
push deployments".

But for QA Engineers, it introduced new headaches. Containers, environment variables, ephemeral filesystems...

If your app follows the 12 Factors, your testing strategy must change from "Test the Server" to "Test the Process".

## TL;DR

- **Config (III) needs testing**: Never hardcode credentials. Test that your app explodes if `DB_PASSWORD` is missing.
- **Disposability (IX) needs verification**: Processes should start fast and die gracefully. Test the shutdown signal
  (`SIGTERM`).
- **Logs (XI) are streams**: Logs are streams, not files. Do not look for `server.log`; listen to `stdout`.

## Factor III: Config

"Store config in the environment". This means your tests should **not** rely on a `config.json` committed to the repo.

**QA Challenge**: Verify that the app correctly reads from `process.env`. If I set `FEATURE_DARK_MODE=true` in the CI
pipeline, does the app actually turn dark? Or did the developer hardcode `false` in `constants.js` because they were
lazy?

## Factor X: Dev/Prod Parity

"Keep development, staging, and production as similar as possible". This is where QAs usually scream into a pillow.

- **Dev**: SQLite (because it is easy).
- **Prod**: PostgreSQL (because it is powerful).
- **Result**: It works in Dev, but breaks in Prod because SQLite does not support JSONB columns correctly.

**The Rule**: Use Docker Compose to force Developers to use the *exact* same database engine as Production.

## Code Snippet: Config Validation

A strict 12-Factor App should refuse to start if its environment variables are missing. Here is a helper to ensure your
app (and your tests) fail fast using `Joi`.

```javascript
// config/validate.js
const Joi = require('joi');

const envSchema = Joi.object({
  NODE_ENV: Joi.string().valid('development', 'production', 'test').required(),
  PORT: Joi.number().default(3000),
  DB_HOST: Joi.string().required(),
  API_KEY: Joi.string().required().description('Stripe API Key'),
})
.unknown(); // Allow other random env vars

const { error, value } = envSchema.validate(process.env);

if (error) {
  console.error('❌ FATAL: Config validation error:', error.message);
  process.exit(1); // Die immediately. Do not pass Go.
}

console.log('✅ Config valid across all environments.');
module.exports = value;

 /* 
  QA Test Case:
  1. Unset DB_HOST.
  2. Run app.
  3. Assert exit code 1.
 */
```

## Summary

The 12-Factor App is strict. It demands discipline.

But it rewards you with an app that can scale from 1 user to 1 million users just by turning a knob. As a QA, your job
is to twist that knob and make sure the wheels do not fall off.

## Key Takeaways

- **Statelessness is mandatory**: Never save an uploaded file to `/tmp`. It will disappear when the container restarts.
  Use S3 instead.
- **Backing Services are detachable**: Treat your database like a detachable resource. Can you swap the URL and connect
  to a replica?
- **Port Binding exports services**: Your app should export services via port binding, not rely on Apache/Nginx
  injection.

## Next Steps

- **Audit**: Search your codebase for `const DB_HOST = 'localhost';`. Shame the developer who wrote it.
- **Chaos**: Kill the container randomly (Disposability). Does it reconnect or hang?
- **Verify**: Ensure `npm test` works inside a Docker container, not just on your host Mac.
