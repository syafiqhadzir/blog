---
layout: post
title: "Pact Contract Testing: Stop Breaking Promises (and APIs)"
date: 2023-11-02
category: QA
slug: api-contract-testing-pact
gpgkey: "EBE8 BD81 6838 1BAF"
---

## Table of Contents

- [Table of Contents](#table-of-contents)
- [Introduction](#introduction)
- [TL;DR](#tldr)
- [The "It Works on My Machine" of Microservices](#the-it-works-on-my-machine-of-microservices)
- [Consumer-Driven Contracts](#consumer-driven-contracts)
- [Code Snippet: Signing the Contract](#code-snippet-signing-the-contract)
- [Summary](#summary)
- [Key Takeaways](#key-takeaways)
- [Next Steps](#next-steps)

## Introduction

In a monolithic world, if you changed a function signature, the compiler would scream at you.

In a microservices world, if you change an API response, the compiler stays silent... until the frontend crashes in production because it expected `userId` (camelCase) but you sent `user_id` (snake_case).

**Contract Testing** (with Pact) is the solution. It is like a legal agreement between services: "I promise to send this JSON, and you promise to understand it."

## TL;DR

- **Problem**: Backend devs change APIs without telling Frontend devs. Chaos ensues.
- **Solution**: The Consumer (Frontend) defines what they need (The Pact).
- **Verification**: The Provider (Backend) runs a test to prove they meet that need.

## The "It Works on My Machine" of Microservices

We have all been there.

**Backend Dev**: "I optimised the User API! It's 50% faster!"
**Frontend Dev**: "Why is the User Profile page blank?"
**Backend Dev**: "Oh, I renamed `fullName` to `full_name`. Didn't you see the Slack message I sent on Friday at 5 PM?"

This is "Integration Hell". You can try to solve it with End-to-End (E2E) tests, but they are slow, flaky, and expensive. Contract tests are fast, stable, and run before you even deploy code to Staging.

## Consumer-Driven Contracts

Pact follows the **Consumer-Driven** philosophy.

Ideally, the *Consumer* (e.g., the React App) says: "I need an endpoint `/user/1` that returns a JSON with an `id` (integer) and a `name` (string)."

This definition generates a **Pact File** (a JSON contract).

The *Provider* (the Go/Java Service) then replays this Pact file against itself. If it fails, the build breaks. No more surprise breakups.

## Code Snippet: Signing the Contract

Here is how you define a contract on the Consumer side using Jest and Pact.

```javascript
// consumer.spec.js
const { PactV3 } = require('@pact-foundation/pact');
const path = require('path');

const provider = new PactV3({
  consumer: 'FrontendApp',
  provider: 'UserService',
  dir: path.resolve(process.cwd(), 'pacts'),
});

describe('User Service API', () => {
  it('returns a user profile', async () => {
    // 1. Define the Expected Interactions
    provider.addInteraction({
      states: [{ description: 'a user with ID 1 exists' }],
      uponReceiving: 'a request for user 1',
      withRequest: {
        method: 'GET',
        path: '/users/1',
      },
      willRespondWith: {
        status: 200,
        body: {
          id: 1,
          name: 'John Doe', // We only care about fields we USE
          role: 'admin'
        },
      },
    });

    // 2. Make the specific request (using your actual API client)
    await provider.executeTest(async (mockServer) => {
        // Assume api.getUser calls the mock server URL
        const response = await api.getUser(1, mockServer.url);
        expect(response.data.name).toEqual('John Doe');
    });
  });
});
```

## Summary

Pact testing is the diplomat of your architecture. It ensures that different services can speak to each other without misunderstanding.

It allows you to deploy services independently, confident that you have not broken the neighbours.

## Key Takeaways

- **Mock the Provider**: The Consumer tests against a "Mock Provider" generated by Pact.
- **Verify the Consumer**: The Provider tests against the "Pact File" generated by the Consumer.
- **Broker It**: Use a Pact Broker (or PactFlow) to share these contracts between pipelines.

## Next Steps

- **Talk**: Sit down with your Backend and Frontend leads. Do they hate each other? Pact might help.
- **Start Small**: Pick one GET endpoint.
- **Automate**: Add the Pact verification step to your CI/CD.
